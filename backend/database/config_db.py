# database/config_db.py
# ============================================
# Conexi√≥n a la base de datos (Async SQLAlchemy)
# ============================================

# ---------------------------
# M√≥dulo interno (config)
# ---------------------------
# De config importamos settings para usar las variables de entorno
from config import settings  # settings.database_url

# ---------------------------
# M√≥dulos externos
# ---------------------------
import ssl
from pathlib import Path
from sqlalchemy.ext.asyncio import async_sessionmaker, create_async_engine
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy import text

# ---------------------------
# Definimos la URL de conexi√≥n
# ---------------------------
# Obtener DATABASE_URL de las variables de entorno
raw_database_url = settings.database_url

# Convertir autom√°ticamente a mysql+aiomysql:// para compatibilidad
if raw_database_url.startswith("mysql://"):
    DATABASE_URL = raw_database_url.replace("mysql://", "mysql+aiomysql://")
elif raw_database_url.startswith("mysql+asyncmy://"):
    DATABASE_URL = raw_database_url.replace("mysql+asyncmy://", "mysql+aiomysql://")
elif not raw_database_url.startswith("mysql+aiomysql://"):
    # Si no tiene el esquema correcto, agregarlo
    if "://" not in raw_database_url:
        DATABASE_URL = f"mysql+aiomysql://{raw_database_url}"
    else:
        DATABASE_URL = raw_database_url
else:
    DATABASE_URL = raw_database_url

print(f"‚úÖ DATABASE_URL configurado para aiomysql")
print(f"üîó Host: {DATABASE_URL.split('@')[1].split('/')[0] if '@' in DATABASE_URL else 'hidden'}")

# ---------------------------
# SSL/TLS para DigitalOcean
# ---------------------------
# DigitalOcean Managed MySQL exige TLS (sslmode=REQUIRED). En Windows, la verificaci√≥n
# suele fallar si no se indica expl√≠citamente la CA del cl√∫ster.
#
# Archivo de CA (descargado desde el panel de DO):
#   backend/certs/ca-certificate.crt
#
# Construimos la ruta de forma robusta relativa a este archivo:
PROJECT_ROOT = Path(__file__).resolve().parents[1]  # .../backend
CA_PATH = PROJECT_ROOT / "certs" / "ca-certificate.crt"

# Configuraci√≥n SSL m√°s robusta para DigitalOcean
def create_ssl_context():
    """Crea un contexto SSL robusto para la conexi√≥n a DigitalOcean"""
    try:
        import os
        import ssl as ssl_module
        
        # Para aiomysql en DigitalOcean, usar configuraci√≥n SSL compatible
        # DigitalOcean Managed MySQL requiere SSL pero con verificaci√≥n espec√≠fica
        
        # En producci√≥n (DigitalOcean), usar SSL sin verificaci√≥n estricta
        if os.getenv("ENVIRONMENT", "development") == "production":
            print("‚úÖ Configurando SSL para producci√≥n (aiomysql + DigitalOcean)")
            # Crear contexto SSL que acepta certificados auto-firmados de DigitalOcean
            ssl_context = ssl_module.create_default_context()
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl_module.CERT_NONE
            # Permitir certificados auto-firmados
            ssl_context.set_ciphers('DEFAULT')
            return {"ssl": ssl_context}
        
        # En desarrollo, usar configuraci√≥n SSL m√°s permisiva
        print("‚úÖ Configurando SSL para desarrollo")
        ssl_context = ssl_module.create_default_context()
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl_module.CERT_NONE
        
        # Intentar cargar certificado CA si existe
        if CA_PATH.exists():
            try:
                ssl_context.load_verify_locations(cafile=str(CA_PATH))
                print(f"‚úÖ Certificado CA cargado: {CA_PATH}")
            except Exception as e:
                print(f"‚ö†Ô∏è No se pudo cargar el certificado CA: {e}")
        
        return {"ssl": ssl_context}
        
    except Exception as e:
        print(f"‚ö†Ô∏è Error configurando SSL: {e}")
        print("‚ö†Ô∏è Fallback a SSL b√°sico")
        return {"ssl": True}

# ---------------------------
# Motor de conexi√≥n as√≠ncrono
# ---------------------------
# NOTA 1: Usando aiomysql para mejor compatibilidad con Windows
# NOTA 2: aiomysql es m√°s f√°cil de instalar y no requiere compilaci√≥n
# NOTA 3: La configuraci√≥n SSL funciona con contextos SSL est√°ndar de Python

# Obtener configuraci√≥n SSL
ssl_config = create_ssl_context()

# Para aiomysql, la configuraci√≥n SSL va en connect_args
connect_args = {
    "charset": "utf8mb4",  # Soporte completo para UTF-8
}

# Agregar configuraci√≥n SSL
if isinstance(ssl_config, dict):
    # Los par√°metros SSL van directamente en connect_args para aiomysql
    connect_args.update(ssl_config)
    print(f"‚úÖ SSL configurado para aiomysql: {list(ssl_config.keys())}")
else:
    # SSL b√°sico por defecto para DigitalOcean
    connect_args["ssl"] = True
    print("‚ö†Ô∏è Usando configuraci√≥n SSL b√°sica por defecto")

engine = create_async_engine(
    DATABASE_URL,
    echo=False,  # Cambiar a False en producci√≥n para mejor performance
    pool_pre_ping=True,  # Evita conexiones zombies (reintento keep-alive)
    pool_recycle=3600,  # Reciclar conexiones cada hora
    pool_size=5,  # N√∫mero de conexiones en el pool
    max_overflow=10,  # Conexiones adicionales permitidas
    connect_args=connect_args,
)

# ---------------------------
# F√°brica de sesiones async
# ---------------------------
async_session = async_sessionmaker(
    engine,
    expire_on_commit=False,  # Mantiene objetos vivos tras commit (√∫til para reusar datos)
)


# ---------------------------
# Base declarativa para los modelos
# ---------------------------
class Base(DeclarativeBase):
    """Base de todos los modelos ORM (Student, Identification, etc.)."""

    pass


# ---------------------------
# Dependencia de sesi√≥n (FastAPI)
# ---------------------------
async def get_session():
    """
    Proporciona una sesi√≥n de base de datos as√≠ncrona por request.
    Se usa con Depends en FastAPI.
    """
    async with async_session() as session:
        yield session


# ---------------------------
# Funci√≥n de verificaci√≥n de conectividad
# ---------------------------
async def verify_database_connection():
    """
    Verifica la conexi√≥n a la base de datos.
    √ötil para health checks y diagn√≥sticos.
    """
    try:
        async with engine.begin() as conn:
            result = await conn.execute(text("SELECT 1 as test"))
            row = result.fetchone()
            return {
                "status": "connected", 
                "test_query": "OK",
                "result": row[0] if row else None,
                "database_url": DATABASE_URL.split('@')[1] if '@' in DATABASE_URL else "hidden"
            }
    except Exception as e:
        import traceback
        return {
            "status": "error", 
            "message": str(e),
            "error_type": type(e).__name__,
            "traceback": traceback.format_exc()
        }


# ---------------------------
# Funci√≥n para cerrar conexiones
# ---------------------------
async def close_database_connections():
    """
    Cierra todas las conexiones de la base de datos.
    √ötil para shutdown graceful.
    """
    await engine.dispose()